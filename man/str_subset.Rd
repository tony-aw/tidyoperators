% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/str_subset.R
\name{\%ss\%}
\alias{\%ss\%}
\alias{\%sget\%}
\alias{\%strim\%}
\alias{s_repl_substr}
\alias{s_chartr_substr}
\alias{s_addin_substr}
\alias{s_extract_substr}
\title{String subsetting functions and operators}
\usage{
x \%ss\% s

x \%sget\% ss

x \%strim\% ss

s_repl_substr(x, rp, loc = NULL, start = NULL, stop = NULL, fish = FALSE, ...)

s_chartr_substr(
  x,
  old = "a-zA-Z",
  new = "A-Za-z",
  loc = NULL,
  start = NULL,
  stop = NULL,
  fish = FALSE,
  ...
)

s_addin_substr(
  x,
  addin,
  side = "after",
  loc = NULL,
  at = NULL,
  fish = FALSE,
  ...
)

s_extract_substr(
  x,
  type = "at",
  loc = NULL,
  start = NULL,
  stop = NULL,
  fish = FALSE,
  ...
)
}
\arguments{
\item{x}{a string or character vector.
See \code{\link{s_pattern_b}}.}

\item{s}{a numeric vector giving the subset indices.}

\item{ss}{a vector of length 2, or a matrix with 2 columns with \code{nrow(ss)==length(x)}.
The object \code{ss} should consist entirely of non-negative integers
(thus 0, 1, 2, etc. are valid, but -1, -2, -3 etc are not valid).
The first element/column of \code{ss}
gives the number of characters counting from the left side to be extracted/removed from \code{x}.
The second element/column of \code{ss}
gives the number of characters counting from the right side to be extracted/removed from \code{x}.}

\item{rp}{a string, or a character vector of the same length as \code{x},
giving the replacing strings.}

\item{loc}{the matrix result from the \link{s_locate_ith} function,
or a manually made 2-column integer matrix,
giving the start (first column) and stop (second column) position
of the range to be modified,  and with \code{nrow(loc)==length(x)}. \cr
NOTE: you cannot fill in both \code{loc} and \code{start,stop},
or both \code{loc} and \code{at}. Choose one or the other.
See \link{s_locate_ith}.}

\item{start, stop}{integers, or integer vectors of the same length as \code{x},
giving the start and stop position of the range to be modified.}

\item{fish}{although \code{tidyoperators} has zero-dependencies,
it does allow the internal functions to use the very fast \code{stringfish}
functions. To do so, set \code{fish=TRUE};
this requires \code{stringfish} to be installed.}

\item{...}{only applicable if \code{fish=TRUE};
other arguments to be passed to the \code{stringfish} functions.}

\item{old, new}{see \link[base]{chartr}.
Defaults to \code{old="a-zA-Z", new="A-Za-z"},
which means upper case characters will be transformed to lower case characters,
and vice-versa.}

\item{addin}{a string, or a character vector of the same length as \code{x},
giving the string(s) to add-in.}

\item{side}{which side of the position to add in the string.
Either \code{"before"} or \code{"after"}.}

\item{at}{an integer, or integer vector of the same length as \code{x}.}

\item{type}{the part of the string to extract. 3 options available: \cr
\itemize{
\item \code{type = "at"}: extracts the string part at the position range; \cr
\item \code{type = "before"}: extracts the string part before the position range; \cr
\item \code{type = "after"}: extracts the string part after the position range. \cr
}}
}
\value{
The \code{\%ss\%} operator always returns a vector or matrix,
where each element is a single character. \cr
\cr
The \code{s_extract_ith()} and \code{s_repl_ith()} functions
return a character vector of the same length as \code{x}. \cr
\cr
The \code{s_locate_ith()} function
returns a numeric vector of the same length as \code{x}.
}
\description{
Pattern-based String subsetting functions. \cr
\cr
The \code{x \%ss\% s } operator
allows indexing a single string as-if it is an iterable object. \cr
\cr
The \code{x \%sget\% ss } operator
gives a certain number of the first and last characters of \code{x}. \cr
\cr
The \code{x \%strim\% ss } operator
removes a certain number of the first and last characters of \code{x}. \cr
\cr
The \code{s_repl_substr(x, rp, ...)} function
replaces a position (range) with string \code{rp}. \cr
\cr
The \code{s_chartr_substr(x, old, new, ...)} function
transforms the sub-string at a position range using \code{chartr(old, new)}. \cr
\cr
The \code{s_addin_substr(x, addin, side, ...)} function
adds the additional string \code{addin} at the side \code{side} of a position. \cr
\cr
The \code{s_extract_substr(x, type, ...)} function
extracts the string at, before, or after some position. \cr
\cr
}
\details{
These operators and functions serve as a way to provide straight-forward string subsetting,
is.null from base R. \cr
\cr
}
\examples{

# numerical substr ====

x <- "12345678910"
start=1; stop=2
s_extract_substr(x, start=start, stop=stop)
s_extract_substr(x, type="before", start=start, stop=stop)
s_extract_substr(x, type="after", start=start, stop=stop)
s_repl_substr(x, "??", start=start, stop=stop)
s_chartr_substr(x, start=start, stop=stop)
s_addin_substr(x, " ", "after", at=stop)
s_addin_substr(x, " ", "before", at=start)

start=10; stop=11
s_extract_substr(x, start=start, stop=stop)
s_extract_substr(x, type="before", start=start, stop=stop)
s_extract_substr(x, type="after", start=start, stop=stop)
s_repl_substr(x, "??", start=start, stop=stop)
s_chartr_substr(x, start=start, stop=stop)
s_addin_substr(x, " ", "after", at=stop)
s_addin_substr(x, " ", "before", at=start)

start=5; stop=6
s_extract_substr(x, start=start, stop=stop)
s_extract_substr(x, type="before", start=start, stop=stop)
s_extract_substr(x, type="after", start=start, stop=stop)
s_repl_substr(x, "??", start=start, stop=stop)
s_chartr_substr(x, start=start, stop=stop)
s_addin_substr(x, " ", "after", at=stop)
s_addin_substr(x, " ", "before", at=start)


#############################################################################

# simple pattern ====

x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
loc <- s_locate_ith(x, c(1, -1), "a|e|i|o|u")
s_extract_substr(x, loc=loc)
s_extract_substr(x, type="before", loc=loc)
s_extract_substr(x, type="after", loc=loc)
s_repl_substr(x, "??", loc=loc)
s_chartr_substr(x, loc=loc)
s_addin_substr(x, " ", "after", loc=loc)
s_addin_substr(x, " ", "before", loc=loc)

#############################################################################

# ignore case pattern ====

x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
# pattern with ignore.case=TRUE:
p <- s_pattern_b("A|E|I|O|U", fixed=FALSE, ignore.case=TRUE, perl=FALSE)
loc <- s_locate_ith(x, c(1, -1), p)
s_extract_substr(x, type="at", loc=loc)
s_extract_substr(x, type="before", loc=loc)
s_extract_substr(x, type="after", loc=loc)
s_repl_substr(x, "??", loc=loc)
s_chartr_substr(x, loc=loc)
s_addin_substr(x, " ", "after", loc=loc)
s_addin_substr(x, " ", "before", loc=loc)

#############################################################################

# multi-character pattern ====

x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
# multi-character pattern:
p <- s_pattern_b("AB", fixed=FALSE, ignore.case=TRUE, perl=FALSE)
loc <- s_locate_ith(x, -1, p)
s_extract_substr(x, loc=loc)
s_extract_substr(x, type="before", loc=loc)
s_extract_substr(x, type="after", loc=loc)
s_repl_substr(x, "??", loc=loc)
s_chartr_substr(x, loc=loc)
s_addin_substr(x, " ", "after", loc=loc)
s_addin_substr(x, " ", "before", loc=loc)

#############################################################################

# perl pattern ====

p <- s_pattern_b("\\\\v+", perl=TRUE) # perl expression; only works with perl=TRUE
x <- "line1 \n line2"
loc <- s_locate_ith(x, -1, p)
s_extract_substr(x, loc=loc)
s_extract_substr(x, type="before", loc=loc)
s_extract_substr(x, type="after", loc=loc)
s_repl_substr(x, "??", loc=loc)
s_chartr_substr(x, loc=loc)
s_addin_substr(x, " ", "after", loc=loc)
s_addin_substr(x, " ", "before", loc=loc)


# for stringi pattern examples: see the Readme file on GitHub.

}
