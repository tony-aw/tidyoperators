---
output:
  github_document:
    toc: true
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
require(badger)
set.seed(1)
```

# tidyoperators

<!-- badges: start -->
`r badge_github_actions("tony-aw/tidyoperators")`
`r badge_repostatus("Active")`
`r badge_lifecycle("experimental")`
`r badge_custom("ORCID", "0000-0001-9498-8379", "green",   "https://orcid.org/0000-0001-9498-8379")`
<!-- badges: end -->

![](tidyoperators.svg)


The 'tidyoperators' R-package adds some much needed infix operators,
    and a few functions,
    to make your R code much more tidy.
    It includes infix operators for the negation of logical operators (exclusive-or, not-and, not-in),
    safer float (in)equality operators,
    in-place modifying mathematical arithmetic,
    string arithmetic,
    string sub-setting,
    in-place modifying string arithmetic,
    in-place modifying string sub-setting,
    "which"-operators,
    and in-place modifying unreal replacers.
    Moreover, it includes some helper functions for more complex string arithmetic,
    some of which are missing from popular R packages like stringi.
    Most stringi pattern expressions options (regex, fixed, coll, charclass)
    are available for all string-pattern-related functions, when appropriate.
    This package also allows integrating third-party parallel computing packages
    for some of its functions.

WARNING: This package is still very much experimental. Function names, argument names, and so on may change dramatically. Use it for testing only, until it's stable.

CHNAGELOG (EXPERIMENTAL VERSION):

 - 8 march 2023: `stringi` is now a dependency. Completely re-written the ReadMe file, Description, and documentation.
 - 9 march 2023: added the "which"-operators.
 - 10 march 2023: `s_strapply()` now uses `stringi`, and uses `apply()` instead of `sapply()`. Renamed the which operators `%[sp]%` and `%[!sp]%` to `%[grep]%` and `%[!grep]%` to make their meaning more obvious. Added this Change log to the ReadMe file.

&nbsp;

## Installation

You can install `tidyoperators` from github like so:

``` r
library(devtools)
devtools::install_github("https://github.com/tony-aw/tidyoperators")
```

then load it using:

```{r}
library(tidyoperators)
```

an one can open the introduction page to the `tidyoperators` package using:

```{r eval=FALSE}
tidyoperators_help()
```


# Overview

The `tidyoperators` R package adds the following functionality:
 
 - Infix logical operators for exclusive-or, not-and, not-in, number-type, and string-type.
 - Safer (in)equality operators for floating numbers.
 - Infix operators for In-place modifiers for mathematical arithmetic.
 - Infix operators for String arithmetic.
 - Infix operators (and a few functions) for string sub-setting.
 - Infix operators for In-place modifying string arithmetic.
 - Infix operators for In-place modifying string sub-setting.
 - Some additional string manipulation functions.
 - Infix operators for general sub-setting ("which"-operators).
 - All `stringi` expressions options (regex, fixed, coll, charclass) are available for all string-pattern-related functions, when appropriate.
 - This R package has only one dependency: `stringi`. No other dependencies, as to avoid "dependency hell".
 - Although this package has no other dependencies, it allows multi-threading of functions (when appropriate) through third-party packages to improve efficiency.
 

I realize there are other R-packages that cover some of the above functionalities. But I often experience that these R packages (or at least those I know of) either do not cover all that I required, had some inconsistencies, or suffered from some other significant drawbacks. Hence this package was created.

Currently this R package is only available on GitHub.

I understand one may not want to go through this entire Read-Me without knowing if the R package is worthy of your time. Therefore, allow me to give you a quick glimpse of what is possible in this R package before jumping into the details.

First, some in-place mathematical arithmetic with `tidyoperators`:

```{r}
x <- 1:10
print(x)
x %^ <-% 2 # is the same as x <- x^2
print(x)
```

Second, some numeric and string sub-types checks:

```{r}
n <- c(0:5, 0:-5, 0.1, -0.1, 0, 1, Inf, -Inf, NA, NaN)
n[n %=numtype% "B"]
n[n %=numtype% "N"]
n[n %=numtype% "I"]
n[n %=numtype% "unreal"]

s <- c(" AbcZ123 ", " abc ", " 1.3 ", " !#$%^&*() ", "  ", "  NA  ", "  NaN  ", " Inf ")
s[s %=strtype% "empty"]
s[s %=strtype% "unreal"]
s[s %=strtype% "numeric"]
s[s %=strtype% "special"]
```


And now some fun string manipulations using `tidyoperators`:

```{r}
x <- c("Hello World", "Goodbye World")

# Capitalize ONLY the ODD indices of each string:
x <- c("Hello World", "Goodbye World")
s_strapply(x, fun=\(x){
  replace(x, seq(1, length(x), 2), toupper(x)[seq(1, length(x), 2)])
})

# Extract second-last vowel of every word of every string in a vector:
x <- c("Outrageous, egregious, preposterous!", "Pleasant evening everyone")
print(x)
p <- s_pattern(regex="a|e|i|o|u", case_insensitive = TRUE)
s_strapply(x, w=T, fun=\(x)s_extract_substr(x, loc=s_locate_ith(x, -2, p)))
```

And some string arithmetic:

```{r}
"Hello" %s+% " world"
c("Hello world", "Goodbye world") %s-% " world"
c("Ha", "Ho", "Hi", "Hu", "He", "Ha") %s*% 10
c("HaHa", "Ho", "Hi", "Hu", "He", "Ha") %s/% "Ha"
```

And string sub-setting:

```{r}
x <- c("yeay nay or nothing to say", "Goodmorning, goodevening and goodnight",
       paste0(letters[1:13], collapse=""))
print(x)
p <- s_pattern(regex = "a|e|i|o|u", case_insensitive=TRUE)
loc <- s_locate_ith(x, -2, p)
s_extract_substr(x, loc=loc) # extract second-last vowel in each string
s_repl_substr(x, "??", loc=loc) # replace second-last vowel with "??"
s_chartr_substr(x, loc=loc) # switch upper/lower case of second-last vowel
s_addin_substr(x, " ", "after", loc=loc) # add white space before second-last vowel
s_addin_substr(x, " ", "before", loc=loc) # add white space after second-last vowel
```

If you're still interested, I invite you to read the rest of this Read-Me and perhaps try out the package yourself.

&nbsp;

# Simple additional logicals

The tidyoperators package adds a few basic logical operators:

 - `%xor%`: Exclusive OR
 - `%n&%`: NOT AND (i.e. `(!x) & (!y)`)
 - `%out%`: the opposite of `%in%` (i.e. `!x %in% y`)
 - `%?=%`: checks if both `x` and `y` are unknown or unreal (NA, NaN, Inf, -Inf)

Here are some examples:

```{r}
x <- c(TRUE, FALSE, TRUE, FALSE, NA, FALSE, TRUE)
y <- c(FALSE, TRUE, TRUE, FALSE, NA, NA, NA)
cbind(x, y, "x %xor% y"=x %xor% y, "x %n&% y" = x %n&% y, "x %?=% y" = x %?=% y)

1:3 %out% 1:10
1:10 %out% 1:3
```



Numbers can have many different sub-types whilst still being `numeric`. The `n %=numtype% numtype` operator will check for every value of numeric vector `n` if it can be considered a number belonging to type `numtype`. The following values for `numtype` are allowed:

 - "~0": zero, or else a number whose absolute value is smaller than the Machine tolerance (`sqrt(.Machine$double.eps)`);
 - "B": binary numbers (0 or 1);
 - "prop": proportions;
 - "N": Natural numbers (non-negative integers including zero);
 - "I": Integers;
 - "odd": odd integers;
 - "even": even integers
 - "R": Real numbers;
 - "unreal": infinity, NA, or NaN;

The string counterpart for `%=numtype%` is `s %=strtype% strtype`, which checks for every value of character vector `s` if it can seen as a certain `strtype`. The following values for `strtype` are allowed:

 - "empty": checks if the string only consists of empty spaces.
 - "unreal": checks if the string is NA, or if it has literal string "NA", "NaN" or "Inf", regardless if it has leading or trailing spaces.
 - "numeric": checks if the string can be converted to a number, disregarding leading and trailing spaces. I.e. the string "5.0" can be converted to the the actual number 5.0.
 - "special": checks if the string consists of only special characters.

Here are some examples:

```{r}

1e-20 %=numtype% "~0"
n <- c(0:5, 0:-5, 0.1, -0.1, 0, 1, Inf, -Inf, NA, NaN)
n[n %=numtype% "B"]
n[n %=numtype% "prop"]
n[n %=numtype% "B"]
n[n %=numtype% "N"]
n[n %=numtype% "I"]
n[n %=numtype% "odd"]
n[n %=numtype% "even"]
n[n %=numtype% "R"]
n[n %=numtype% "unreal"]

s <- c(" AbcZ123 ", " abc ", " 1.3 ", " !#$%^&*() ", "  ", "  NA  ", "  NaN  ", " Inf ")
s[s %=strtype% "empty"]
s[s %=strtype% "unreal"]
s[s %=strtype% "numeric"]
s[s %=strtype% "special"]
```


&nbsp;

# Safer float (in)equality operators

This package adds the `%f==%, %f!=% %f<%, %f>%, %f<=%, %f>=%` operators, which perform "float logic". They are virtually equivalent to the regular (in)equality operators,
`==, !=, <, >, <=, >=`,
except for one aspect. The float logic operators assume that if the absolute difference between `x` and `y` is smaller than the Machine tolerance, `sqrt(.Machine$double.eps)`, then `x` and `y` ought to be consider to be equal.
Thus these provide safer float (in)equality operators.
For example: `(0.1*7) == 0.7` returns `FALSE`, even though they are equal, due to the way floating numbers are stored in programming languages like R. But `(0.1*7) %f==% 0.7` returns `TRUE`.

Some examples:

```{r}
x <- c(0.3, 0.6, 0.7)
y <- c(0.1*3, 0.1*6, 0.1*7)
print(x); print(y)
x == y # gives FALSE, but should be TRUE
x!= y # gives TRUE, should be FALSE
x > y # not wrong
x < y # gives TRUE, should be FALSE
x %f==% y # here it's done correctly
x %f!=% y
x %f<% y # correct
x %f>% y # correct
x %f<=% y # correct
x %f>=% y # correct
```

Although designed for objects (vectors, matrices, arrays) of class `double` (floating numbers), these operators also work correctly for integers. These operators do not work for non-numeric objects.

&nbsp;

# In-place modifying mathematical arithmetic

## The problem

This R package includes infix operators for in-place modifying mathematical arithmetic. But first: what is an in-place modifier?
Consider the following line of code:

```{r eval=FALSE}
mtcars$mpg[mtcars$cyl>6] <- mtcars$mpg[mtcars$cyl>6]^2
```

The same expression, `mtcars$mpg[mtcars$cyl>6]`, is written twice, making this code rather long and cumbersome, even though we're just squaring the expression. The well-known `magrittr` R-package has an in-place modifier pipe, `%<>%`. This works excellent for actual functions, like so:

```{r eval=FALSE}
mtcars$mpg[mtcars$cyl>6] %<>% mean() # same as mtcars$mpg[mtcars$cyl>6] <- mean(mtcars$mpg[mtcars$cyl>6])
```
 
But for arithmetic, one needs to translate the operators into a function, and then perform the in-place modifier pipe:


```{r eval=FALSE}
mtcars$mpg[mtcars$cyl>6] %<>% raise_to_power(2)
```

This is better, but still not truly tidy.

&nbsp;

## The solution from this R package

This R package solves the above laid-out problem by implementing in-place modifying mathematical arithmetic for all mathematical operators, excluding matrix operators.

Here is a list of all in-place mathematical modifiers implemented in this R-package:

 - `x %+ <-% y` is the same as`x <- x + y`;
 - `x %- <-% y` is the same as`x <- x - y`;
 - `x %* <-% y` is the same as`x <- x * y`;
 - `x %/ <-% y` is the same as`x <- x / y`;
 - `x %^ <-% p` is the same as`x <- x^p`;
 - `x %rt <-% p` is the same as`x <- x^(1/p)`;
 - `x %logb <-% b` is the same as`x <- log(x, base=b)`;
 - `x %alogb <-% b` is the same as`x <- b^x`; if `b=exp(1)`, this is the same as`x <- exp(x)`;
 - `x %alogb <-% exp(1)` is the same as exp(x)`.


I realize there doesn't really need to be a `%logb%` operator, but since one was needed for the antilogarithm, I added the "regular" logarithm also, for consistency.
Notice that all in-place modifiers end with `   <-%` (notice the space). All infix operators that are in-place modifiers in this R package end with ` <-%`, so that it is clear what it does.

Lets look at the original problem:

```{r eval=FALSE}
mtcars$mpg[mtcars$cyl>6] <- mtcars$mpg[mtcars$cyl>6]^2
```

With `tidyoperators` one can now make this more tidy with the following:

```{r eval=FALSE}
mtcars$mpg[mtcars$cyl>6] %^ <-% 2
```

Much tidier, no?

&nbsp;


This is not the first or only R package that incorporates in-place modifiers. Most notably, the `inplace` R package is devoted entirely to in-place modifying mathematical arithmetic. However, `inplace` has a nasty side-effect:

If 2 R objects refer to the same values - let's say `x = 3` and `y = 3` - using an in-place modifier from the `inplace` package on `x` will also change `y`. This can be very dangerous.

**The `tidyoperators` R package does not have this problem:** modifying one object does not affect another object, even if they happen to have the same value.


&nbsp;

# Unreal replacement

Another operator added by `tidyoperators` is `x %unreal <-% y`, which replaces all NA, NaN, Inf and -Inf in `x` with the value given in `y`.

It is the same as `x[is.na(x)|is.nan(x)|is.infinite(x)] <- y`.

&nbsp;

# Basic string operations


The `tidyoperators` R package implements operators for string arithmetic and sub-setting, as well some of their in-place modifier equivalents. For consistency, and to avoid masking other common operators, all string-related operators start with `%s`, where the "s" stands for "string". Likewise, all string-related functions in this package start with `s_`.
(The only exceptions to this naming convention are  `%[grep]%` and `%[!grep]%`, though these are "which"-operators, technically, which are discussed near the end of this read-me.)

&nbsp;

## Locate ith pattern

In order to use the string sub-setting functions and operators optimally, this R package includes a helper function called `s_locate_ith(x, i, p)`. This function locates for every element/string in character vector `x` the $i^{th}$ occurrence of pattern `p`. When `i` is positive, the occurrence is counted from left to right. Negative values for `i` are also allowed, in which case the occurrence is counted from the right to left. Thus, to get the **last** occurrence, use `i=-1`. But `i=0` is not allowed though.

It returns a matrix with 3 columns:

 - The first column gives the start position of the $i^{th}$ occurrence of pattern `p`.
 - The second column gives the end position of the $i^{th}$ occurrence of pattern `p`.
 - The third column gives the length of the position range of the $i^{th}$ occurrence of pattern `p`.

The returned matrix can be used directly into the string sub-setting functions, in the `loc` argument.

The `s_locate_ith(x, i, p)` is a vectorized function: `x, i, p` can all be different-valued vectors.

&nbsp;

## String sub-setting functions

The `tidyoperators` R-package includes the following sub-setting functions:

 - The `s_repl_substr(x, rp, ...)` function replaces a position (range) with string `rp`.
 - The `s_chartr_substr(x, old, new, ...)` function transforms the sub-string at a position (range) using `chartr(old, new)`. By default, it will translate upper-case characters to lower-case, and vice-versa.
 - The `s_addin_substr(x, addin, side, ...)` function adds the additional string `addin` at the side `side` of a position.
 - The `s_extract_substr(x, type, ...)` function extracts the string at, before, or after some position (range).

The "position" in the functions above can be specified either by giving the result of the `s_locate_ith()` function in argument `loc`, or by one can give manual numerical specifications using the `start, stop` or `at` arguments. 

For example:

```{r}
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
p <- "a|e|i|o|u" # specify pattern
loc <- s_locate_ith(x, 1, p) # find first occurrence of pattern p
s_extract_substr(x, loc=loc) # extract pattern
s_extract_substr(x, type="before", loc=loc) # extract string before pattern
s_extract_substr(x, type="after", loc=loc) # extract string after pattern
s_repl_substr(x, "??", loc=loc) # replace pattern with double question-mark
s_chartr_substr(x, loc=loc) # transform case of pattern match
s_addin_substr(x, " ", "after", loc=loc) # add white space before pattern
s_addin_substr(x, " ", "before", loc=loc) # add white space after pattern

```

Simple, right?



&nbsp;

## String subsetting operators

As a first sub-setting operator, we have `x %sget% ss`, which returns a subset of each string in character vector `x`. Here `ss` is a vector of length 2, or a matrix with `nrow(ss)=length(x)` and 2 columns. The object `ss` should consist entirely of non-negative integers (thus 0, 1, 2, etc. are valid, but -1, -2, -3 etc are not valid). The first element/column of ss gives the number of characters counting from the left side to be extracted from x. The second element/column of ss gives the number of characters counting from the right side to be extracted from x.

Here are 2 examples:

```{r}
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
ss <- c(2,3)
x %sget% ss

x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
ss <- c(1,0)
x %sget% ss
```

Thus `%sget%` "gets" or extracts the given number of characters from the left and the right, and removes the rest.
There is also `%strim%`, which is the opposite: it trims away the number of characters from the left and right as defined in `ss`, leaving you with whatever is left.

Here are again 2 examples:

```{r}
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
ss <- c(2,3)
x %strim% ss

x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
ss <- c(1,0)
x %strim% ss
```

&nbsp;


Another fun string operator is `x %ss%  s`. This essentially splits character vector `x` into a vector containing only individual characters; then this vector is subset-ted by the number given in `s`. Honestly, I do not think one would need this often, but it can be handy sometimes. For example:

```{r}
x <- "Tom Marvolo Riddle"
toupper(x) %ss% c(14, 4, 6:5, 12, 10:11, 13, 15, 8:9, 17:16, 18, 3:2, 7, 1) |>
  paste0(collapse = "")
```


&nbsp; 


## String arithmetic

Certainly, the `tidyoperators` package is not the first R package to introduce string arithmetic. But I do hope these operators have more consistent naming and functionality.

The `tidyoperators` package adds 4 arithmetic operators:

 - `x %s+% y` is the same as `paste0(x, y)`;
 - `x %s-% p` removes pattern `p` from each string in character vector `x`;
 - `x %s*% n` repeats each string in character vector `x` for `n` times;
 - `x %s/% p` counts how often pattern `p` occurs in string or vector `x`
 
I.e.:

```{r}
"Hello "%s+% " world"
c("Hello world", "Goodbye world") %s-% " world"
c("Ha", "Ho", "Hi", "Hu", "He", "Ha") %s*% 2:7
x <- c("Ha", "Ho", "Hi", "Hu", "He", "Ha") %s*% 10
c("hello world & goodbye world", "world domination!") %s/% "world"
```

The tidyoperators R package also includes several string sub-setting functions.


It is important to note that the right-side arguments `p`, `y`, and `n` can be a single value, or a vector of the same length as `x`.

&nbsp;

## Pattern attributes in strings

The `x %s-% p` and `x %s/% p` operators (and their in-place equivalents, given later), and the `s_locate_ith()` functions perform pattern matching for subtracting, counting, and locating patterns, respectively. By default the pattern matching is interpreted as case-sensitive `regex` patterns from `stringi`.

But, of course, sometimes one wants to change this. For example, one may want it to be case insensitive. Or perhaps one wants to use fixed expressions, or something else.

The `tidyoperators` package provides options for these cases. To use more refined pattern definition, simply replace the argument/right-hand-side expression `p` in the relevant functions/operators with a call from the `s_pattern()` function.

The `s_pattern()` function uses the exact same argument convention as `stringi`. For example:

 - `s_pattern(regex=p, case_insensitive=FALSE, ...)`
 - `s_pattern(fixed=p, ...)`
 - `s_pattern(coll=p, ...)`
 - `s_pattern(boundary=p, ...)`
 - `s_pattern(charclass=p, ...)`

For consistency with base R and with packages such as `stringr`, one can also fill in `ignore.case=TRUE` or `ignore_case=TRUE` instead of `case_insensitive=TRUE`, and `s_pattern()` will still understand that.

&nbsp;

## Pattern attributes examples

```{r}
# VOWELS SUBSETTING ====

x <- c("yeay nay or nothing to say", "Goodmorning, goodevening and goodnight",
       paste0(letters[1:13], collapse=""))
print(x)
p <- s_pattern(regex = "a|e|i|o|u", case_insensitive=TRUE)

loc <- s_locate_ith(x, c(1, -1, -1), p)
s_extract_substr(x, loc=loc)
s_extract_substr(x, type="before", loc=loc)
s_extract_substr(x, type="after", loc=loc)
s_repl_substr(x, "??", loc=loc)
s_chartr_substr(x, loc=loc)
s_addin_substr(x, " ", "after", loc=loc)
s_addin_substr(x, " ", "before", loc=loc)


# MULTI-CHAR SUBSETTING ====

x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
p <- s_pattern(regex="AB", case_insensitive=TRUE)
loc <- s_locate_ith(x, c(1, -1), p)
s_extract_substr(x, loc=loc)
s_extract_substr(x, type="before", loc=loc)
s_extract_substr(x, type="after", loc=loc)
s_repl_substr(x, "??", loc=loc)
s_chartr_substr(x, loc=loc)
s_addin_substr(x, " ", "after", loc=loc)
s_addin_substr(x, " ", "before", loc=loc)

# PATTERN ARITHMETIC ====

x <- c("Hello world", "Goodbye world")
p <- s_pattern(regex=" world")
x %s-% p


x <- c("Ha", "Ho", "Hi", "Hu", "He", "Ha") %s*% 10
p <- s_pattern(regex="Ha")
x %s/% p

```

And then some fixed expressions:

```{r}
x <- c("yeay yeay yeay yeay", "nay nay nay nay")
p <- s_pattern(fixed = "ye")

rp <- "?"
loc <- s_locate_ith(x, -1, p)
s_extract_substr(x, loc=loc)
s_extract_substr(x, type="before", loc=loc)
s_extract_substr(x, type="after", loc=loc)
s_repl_substr(x, "??", loc=loc)
s_chartr_substr(x, loc=loc)
s_addin_substr(x, " ", "after", loc=loc)
s_addin_substr(x, " ", "before", loc=loc)

x <- c("Hello world", "Goodbye world")
p <- s_pattern(fixed=" world")
x %s-% p

x <- c("Ha", "Ho", "Hi", "Hu", "He", "Ha") %s*% 10
p <- s_pattern(coll="Ha")
x %s/% p

```

And so on. I'm sure you get the idea.


&nbsp;

## In-place modifying string arithmetic and subsetting

With the exception of  `%ss%`, all infix operators (notice: operators, not functions) have their in-place modifying equivalent:

 - `x %s+ <-% y` is the same as `x <- x %s+% y`
 - `x %s- <-% p` is the same as `x <- x %s-% p`
 - `x %s* <-% n` is the same as `x <- x %s*% n`
 - `x %s/ <-% p` is the same as `x <- x %s/% p`
 - `x %sget <-% ss` is the same as `x <- x %sget% ss`
 - `x %strim <-% ss` is the same as `x <- x %strim% ss`

The `s_extract_ith()` and `s_repl_ith()` functions obviously do not require an in-place modifier version, as they can easily be used in combination with `magrittr`'s in-place pipe modifier ( `%<>%` ),  just like any other function.

&nbsp;

# More advanced string operations with s_strapply

The string arithmetic and sub-setting operators and functions given so far - in combination with the string function already available in base R and R packages such as `stringi` - can do a lot, but it's not always flexible enough. To add extra flexibility, there is also the `s_strapply(x, fun, w=F, clp=NULL, ...)` function. This function applies the following steps to every element (every string) of character vector x:

 1) the string is split into a vector of single characters (`w=F`), or a vector of space-delimited words (`w=T`).
 2) the function `fun()` is applied to the vector from step 1.
 3) the result from step 2 is pasted together to form a single string element again, using `paste0(..., collapse=clp)`. By default, `clp=""` if `w=F`, and `clp=" "` if `w=T`.

In other words, this function turns every string in character vector `x` into its own little vector, applies a function to this vector, and pastes the returning vector together into a single string again.

This operator can be used in a very wide variety of ways.

One obvious use of this function is for re-arranging the characters or words in every string in character vector `x`, or find the occurrence of the character on the alphabet:

```{r}
x <- c("Hello World", "Goodbye World")
s_strapply(x, sort) # sort letters
s_strapply(x, sample) # randomly shuffle letters
s_strapply(x, rev, w=T) # reverse words
# find occurrence of characters on alphabet:
s_strapply(x, fun=\(x)match(tolower(x),letters), clp="; ")
```

I think this is reasonably easy and tidy.

Lets try something else: capitalize characters but ONLY at certain indices:

```{r}
x <- c("Hello World", "Goodbye World")
# capitalize odd indices:
s_strapply(x, fun=\(x){
  replace(x, seq(1, length(x), 2), toupper(x)[seq(1, length(x), 2)])
})

# capitalize random letters:
s_strapply(x, fun=\(x){
  ind <- sample(1:length(x), size=floor(length(x)/2))
  replace(x, ind, toupper(x[ind]))
})

# capitalize only first word:
s_strapply(x, fun=\(x){replace(x, 1, toupper(x[1]))}, w=T)
```


Lets try to take the second-last vowel of every word of every string in some character vector `x`:

```{r}
x <- c("Outrageous, egregious, preposterous!", "Pleasant evening everyone")
print(x)
p <- s_pattern(regex="a|e|i|o|u", case_insensitive = TRUE)
s_strapply(x, w=T, fun=\(x)s_extract_substr(x, loc=s_locate_ith(x, -2, p)))
```

&nbsp;

# "which"-operators

The final category of operators in this package are the "which"-operators.

These operators are designed to simplify operations where one subsets an object based on conditions referring to itself.
For example: in `x[x>0]`, the object `x` is sub-setted based on conditions referring to itself. Thus, `x` is written twice. If the object has a short name like `x`, these operators do not necessarily make your code tidier (except for perhaps pattern matching). But if `x` has a longer name like `very_long_name_1`, doing `very_long_name_1[very_long_name_1>0]` becomes cumbersome. The tidyoperators package adds several "which"-operators, which will tidy this up a bit.

All which-operators are surrounded by a `%[` and a `]%`

The which operators are as follows:

 - The `x %[fun]% fun` operator selects elements from vector/matrix `x`, for which the result of `fun(x)` returns `TRUE`.
 - The `x %[!fun]% fun` operator selects elements from vector/matrix `x`, for which the result of `fun(x)` returns FALSE.
 - The `s %[grep]% p` operator selects elements from character vector `s` if they contain pattern `p`.
 - The `s %[!grep]% p` operator selects elements from character vector s if they do NOT contain pattern `p`.
 - The `n %[intv]% ss` operator selects elements from numeric vector/matrix/array `n`, whose values are within the interval defined by `ss`.
 - The `n %[!intv]% ss` operator selects elements from numeric vector/matrix/array `n`, whose values are outside the interval defined by `ss`.
 
As was the case with the string operators, pattern `p` can be a vector of regular expressions, or a call from the `s_pattern()` function.

Here are a few examples to see these operators in action:

```{r}
object_with_very_long_name <- -5:5
object_with_very_long_name %[fun]% \(x)x %in% c(1, 3, 5, 7)
object_with_very_long_name %[!fun]% \(x)x %in% c(1, 3, 5, 7)
n <- matrix(-5:4, ncol=2)
ss <- cbind(rep(-2, length(n)), rep(2, length(n)))
n %[intv]% ss
n %[!intv]% ss
s <- c("hello world", "goodbye world")
p <- s_pattern(regex = rep("hello", 2))
s %[grep]% p
s %[!grep]% p
```

&nbsp;

# Speed, efficiency, and multi-threading

This section discusses speed and optimization in the `tidyoperators` package.

## Multi-threading in string subsetting functions

All the string sub-setting functions have the `fish` argument, which is `FALSE` by default. If `fish=TRUE`, these functions will use `stringfish` functions instead of base R functions, which are faster, and also allow native multi-threading. Note that `stringfish` must be installed in order for this to work. And `stringfish` needs to be loaded also if you wish to also use multi-threading. Multi-threading in `stringfish` can be set-up by running `setoption(stringfish.nthreads=cl)` somewhere at the start of your code, where `cl` is the number of threads you want to use.

Don't use multi-threading unless you need to, as multi-threading has some overhead, thus its only faster with very large character strings.

&nbsp;

## Multi-threading in s_locate_ith

The `s_locate_ith()` function internally use `mapply()`. This function has the `custom_mapply` argument, which allows the user to replace the internally used `mapply()` with a user provided alternative. The primary usage of this is for multi-threading (though it could, technically, also be used for other reasons). It is important that whatever replacer function the user provides, it must have the same argument names and usage as base R `mapply()`.

For example, suppose one wants to speed up `s_locate_ith()` using parallel computing. One can use the `future.apply::future_mapply()` as a replacer for the mapply function, like so:

```{r eval=FALSE}

x <- rep(c("Hello World", "Goodbye World"), 2e5)
p <- s_pattern(regex="a|e|i|o|u", case_insensitive=TRUE)

s_locate_ith(x, -1, p) # regular way

require(future.apply)
plan(multisession)
s_locatet_ith(x, -1, p, custom_mapply = future_mapply) # multi-threaded way.
```

Now you have a multithreaded version of `s_locate_ith`; that wasn't so difficult, right? On my computer, the multi-threaded command was about 3 times faster.


## Multi-threading in s_strapply


The `s_strapply` function uses `apply` internally. Just like in `s_locate_ith`, the user can multi-thread this function by replacing apply:

```{r eval=FALSE}
x <- rep(c("Hello World", "Goodbye World"), 2e5)

s_strapply(x, sort) # regular way

require(future.apply)
plan(multisession)
s_strapply(x, sort, custom_apply = future_apply) # multi-threaded way
```

Now you have a multi-threaded version of `s_strapply`.

If you combine `s_strapply` with another multi-threaded function, I advice the user to only make `s_strapply` multi-threaded, and not the function used in the `fun` argument; making multiple layers of parallel computing seems like asking for problems.

For example, when combining `s_strapply` and `s_locate_ith`, only multi-thread `s_strapply` with a replacing `apply` function; do not do so with `s_locate_ith`. I.e.:

```{r eval=FALSE}
x <- rep(
  c("Outrageous, egregious, preposterous!", "Pleasant evening everyone"),
  1e5
)
# s_strapply combined with s_locate_ith:
p <- s_pattern(regex = "a|e|i|o|u", case_insensitive = TRUE) 
s_strapply(x, w=T, fun=\(x){
  s_repl(x, "??", loc=s_locate_ith(x, -2, p))
}, custom_apply = future_apply)
```

Notice that only `s_strapply()` is multi-threaded, and not `s_locate_ith`. Multi-threading both would actually be slower, and may even create other problems.

&nbsp;


# Recommended R packages

`stringi` is of course required for this packages. Besides that, I highly recommend using this R package alongside the 2 major operator-related R-packages, namely `magrittr` and `zeallot`.
&nbsp;

# Compatibility with other operator-related R packages

The `stringi` R package has the `%s+%` and `%s*%` operators. They do virtually the same things as in `tidyoperators`, and so the masking of these functions can safely be ignored. I also made sure not to name any of the operators in `tidyoperators` the same as the operators in `magrittr` and `zeallot`, so that should be safe also.

&nbsp;

# Conclusion

I hope this R package will make your life a little bit tidyr.

